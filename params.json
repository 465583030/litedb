{
  "name": "Litedb",
  "tagline": "A lite mysql operator lib for golang",
  "body": "# litedb\r\n--\r\n    import \"litedb\"\r\n\r\n一个轻便以及追求SQL性能的MYSQL客户端\r\n\r\n#### Intro\r\n\r\n    LiteDB 的核心设计目标是提供一个轻量级的SQL封装.\r\n    LiteDB 不会对设计范式与Mysql本身做更多的侵入\r\n    LiteDB 提供基本的SQL CURD封装\r\n    LiteDB 不提供任何形式的SQLBuilder\r\n    LiteDB 使用 `database/sql` 和 mysql驱动\r\n\r\n#### Init\r\n\r\n```go\r\n\r\n    host        := \"127.0.0.1\"\r\n    port        := 3306\r\n    user        := \"root\"\r\n    password    := \"root\"\r\n    database    := \"database_name\"\r\n\r\n   client := litedb.NewTcpClient(host,port,user,password,database)\r\n\r\n```\r\n\r\n#### Configure\r\n\r\n```go\r\n\r\n    client.Config.Set(\"timeout\",\"5\")\r\n    client.Config.Set(\"charset\",\"utf8\")\r\n```\r\n\r\n#### Query\r\n\r\n```go\r\n\r\n fullSql := \"SELECT * FROM `my_table` LIMIT 10\"\r\n\r\n ret := client.Query(fullSql)\r\n\r\n sql := \"SELECT * FROM `my_table` where id = ?\"\r\n\r\n ret := client.Query(sql,1)\r\n\r\n\r\n if err.Err != nil {\r\n    //errro\r\n\r\n }else{\r\n\r\n      maps,err := ret.ToMap()   //存储到一个[]map[string]string对象中\r\n      first,err := ret.FirstToMap() //将首行存储到一个map[string]string对象中\r\n\r\n      type Temp struct {\r\n\r\n        Id      int `db:\"id\"`\r\n        Name    string `db:\"name\"`\r\n\r\n      }\r\n\r\n     var listData []Temp\r\n\r\n     err := ret.ToStruct(&listData)             //将全部结果存储到结构体中,使用db:\"mysql_field_name\"的形式进行数据库字段映射\r\n\r\n     var data Temp\r\n\r\n     err := ret.FirstToStruct(&data)            //将首行存储到一个结构体中\r\n\r\n }\r\n\r\n\r\n```\r\n\r\n#### Insert\r\n\r\n```go\r\n\r\n type Temp struct {\r\n\r\n        Id      int `db:\"id\"`\r\n        Name    string `db:\"name\"`\r\n\r\n   }\r\n\r\n   newData := &Temp{\r\n     Name : \"my name\"\r\n   }\r\n\r\n\r\n    ret := client.Insert(\"table\",newData)\r\n\r\n    if ret.Err != nil {\r\n\r\n    }\r\n\r\n```\r\n\r\n\r\n#### Update\r\n```go\r\n\r\n type Temp struct {\r\n\r\n        Id      int `db:\"id\"`\r\n        Name    string `db:\"name\"`\r\n\r\n   }\r\n\r\n   newData := &Temp{\r\n     Name : \"my new name\"\r\n   }\r\n\r\n    ret := client.Insert(\"table\",newData,\"id=?\",1)\r\n\r\n    if ret.Err != nil {\r\n\r\n    }\r\n\r\n```\r\n\r\n#### Delete\r\n```go\r\n\r\n    ret := client.Delete(\"table\",\"id=?\",1)\r\n\r\n    if ret.Err != nil {\r\n\r\n    }\r\n\r\n```\r\n\r\n## Usage\r\n\r\n```go\r\ntype Client struct {\r\n\tSql\r\n\tHost     string\r\n\tPort     uint32\r\n\tUser     string\r\n\tPassword string\r\n\tDatabase string\r\n\tProtocol string\r\n\tConfig   *ClientDNSConfigure\r\n}\r\n```\r\n客户端\r\n\r\n#### func  NewClient\r\n\r\n```go\r\nfunc NewClient(protocol string, host string, port uint32, user string, password string, database string) *Client\r\n```\r\n初始化数据库 此时并未打开连接池 只有在真实需要与数据库交互的时候才会进行连接.\r\n\r\n#### func  NewTcpClient\r\n\r\n```go\r\nfunc NewTcpClient(host string, port uint32, user string, password string, database string) *Client\r\n```\r\n初始化一个TCP客户端\r\n\r\n#### func (*Client) Begin\r\n\r\n```go\r\nfunc (this *Client) Begin() (*Transaction, error)\r\n```\r\n开启事务\r\n\r\n#### func (*Client) Close\r\n\r\n```go\r\nfunc (this *Client) Close() error\r\n```\r\n关闭数据库\r\n\r\n#### func (*Client) Exec\r\n\r\n```go\r\nfunc (this *Client) Exec(sqlFmt string, sqlValue ...interface{}) *ClientExecResult\r\n```\r\nUPDATE `Table` SET `field_1` = Value Where id = 1 UPDATE SET `field_1` = ? WHERE\r\nid = ? ,Value,1 支持完整的SQL语句与?占位符.对于?占位符的使用请参考官方文档 ?占位符是字符串安全的,请尽量使用?占位符\r\n\r\n#### func (*Client) Ping\r\n\r\n```go\r\nfunc (this *Client) Ping() error\r\n```\r\nping\r\n\r\n#### func (*Client) Query\r\n\r\n```go\r\nfunc (this *Client) Query(sqlFmt string, sqlValue ...interface{}) *ClientQueryResult\r\n```\r\nSELECT * FROM Table WHERE id = 1 SELECT * FROM Table WHERE id = ?\r\n支持完整的SQL语句与?占位符.对于?占位符的使用请参考官方文档 ?占位符是字符串安全的,请尽量使用?占位符\r\n\r\n#### type ClientDNSConfigure\r\n\r\n```go\r\ntype ClientDNSConfigure struct {\r\n}\r\n```\r\n\r\n客户端DNS配置\r\n\r\n#### func  NewClientDnsConfigure\r\n\r\n```go\r\nfunc NewClientDnsConfigure() *ClientDNSConfigure\r\n```\r\n\r\n#### func (*ClientDNSConfigure) Parse\r\n\r\n```go\r\nfunc (this *ClientDNSConfigure) Parse() string\r\n```\r\n将起解析DNS格式的字符串\r\n\r\n#### func (*ClientDNSConfigure) Remove\r\n\r\n```go\r\nfunc (this *ClientDNSConfigure) Remove(k string) bool\r\n```\r\n移除设置 Remove(\"timeout\")\r\n\r\n#### func (*ClientDNSConfigure) Set\r\n\r\n```go\r\nfunc (this *ClientDNSConfigure) Set(k, v string) bool\r\n```\r\n设置一个客户端DNS设置. Set(\"timeout\",\"5\") 详细信息请参考golang mysql DNS语法\r\n\r\n#### type ClientExecResult\r\n\r\n```go\r\ntype ClientExecResult struct {\r\n\tResult sql.Result\r\n\tErr    error\r\n}\r\n```\r\n\r\nClient.Exec 的结果\r\n\r\n#### type ClientQueryResult\r\n\r\n```go\r\ntype ClientQueryResult struct {\r\n\tRows *sql.Rows\r\n\tErr  error\r\n}\r\n```\r\n\r\nClient.Query 的结果\r\n\r\n#### func (*ClientQueryResult) FirstToMap\r\n\r\n```go\r\nfunc (this *ClientQueryResult) FirstToMap() (map[string]string, error)\r\n```\r\n将Rows中的首行解析成一个map[string]string\r\n\r\n#### func (*ClientQueryResult) FirstToStruct\r\n\r\n```go\r\nfunc (this *ClientQueryResult) FirstToStruct(v interface{}) error\r\n```\r\n将首行解析成一个Struct ,需要传递一个 struct的指针. struct 定义中使用标签 tag 来进行数据库字段映射,比如 struct {\r\n\r\n    \t Id int `db:\"id\"`\r\n      Name string `db:\"name\"`\r\n\r\n}\r\n\r\n#### func (*ClientQueryResult) ToMap\r\n\r\n```go\r\nfunc (this *ClientQueryResult) ToMap() ([]map[string]string, error)\r\n```\r\nToMap 将结果集转换为Map类型. 这个操作不进行任何类型转换. 因为这里的类型转换需要一次SQL去反射字段类型. 更多的时候会得不偿失.\r\n\r\n#### func (*ClientQueryResult) ToStruct\r\n\r\n```go\r\nfunc (this *ClientQueryResult) ToStruct(containers interface{}) error\r\n```\r\n将结果集转换成一个struct 数组 var containers []Person\r\n\r\nToStruct(&containers) 对于struct类型,支持以下字段类型: int8\r\n\r\nint16\r\n\r\nint32\r\n\r\nint64\r\n\r\nint\r\n\r\nuint8\r\n\r\nuint16\r\n\r\nuint32\r\n\r\nuint64\r\n\r\nuint\r\n\r\nfloat32\r\n\r\nfloat64\r\n\r\nstring\r\n\r\n[]byte\r\n\r\n\r\n\r\n#### type Sql\r\n\r\n```go\r\ntype Sql struct{}\r\n```\r\n\r\nSql操作集\r\n\r\n#### func (*Sql) BatchInsert\r\n\r\n```go\r\nfunc (this *Sql) BatchInsert(table string, vs interface{}) *ClientExecResult\r\n```\r\n批量插入 SQL语句为: REPLACE INTO `%s` (field,field) VALUES (?,?),(?,?) 我们为什么使用REPLACE\r\nINTO 来支持批量插入. 使用Insert Into 的问题是全部待插入的数据行是事务一致的.因此,对于一次插入中,只要有行已经存在,则全部插入失败.\r\n\r\n#### func (*Sql) Delete\r\n\r\n```go\r\nfunc (this *Sql) Delete(table string, whereFmt string, whereValue ...interface{}) *ClientExecResult\r\n```\r\n根据Where条件删除数据\r\n\r\n#### func (*Sql) Exec\r\n\r\n```go\r\nfunc (this *Sql) Exec(sqlFmt string, sqlValue ...interface{}) *ClientExecResult\r\n```\r\nnot implement anythings\r\n\r\n#### func (*Sql) Insert\r\n\r\n```go\r\nfunc (this *Sql) Insert(table string, v interface{}) *ClientExecResult\r\n```\r\n对Struct类型的支持,使用 db tag 进行数据库字段映射 对Map类型会将value转换为string.请确保map类型中只包含基本数据类型\r\n\r\n#### func (*Sql) InsertOrUpdate\r\n\r\n```go\r\nfunc (this *Sql) InsertOrUpdate(table string, v interface{}) *ClientExecResult\r\n```\r\n插入或更新行(当主键已存在的时候) SQL语句为: INSERT INTO .... ON DUPLICATE KEY UPDATE .... 全部字段更新\r\n\r\n#### func (*Sql) InsertOrUpdateFields\r\n\r\n```go\r\nfunc (this *Sql) InsertOrUpdateFields(table string, v interface{}, updateFields ...string) *ClientExecResult\r\n```\r\nmap类型无必要使用该方法 插入或更新行(当主键已存在的时候) SQL语句为: INSERT INTO .... ON DUPLICATE KEY UPDATE\r\n.... 可以指定更新字段\r\n\r\n#### func (*Sql) Query\r\n\r\n```go\r\nfunc (this *Sql) Query(sqlFmt string, sqlValue ...interface{}) *ClientQueryResult\r\n```\r\nnot implement anythings\r\n\r\n#### func (*Sql) Update\r\n\r\n```go\r\nfunc (this *Sql) Update(table string, v interface{}, whereFmt string, whereValue ...interface{}) *ClientExecResult\r\n```\r\n对Struct类型的支持,使用 db tag 进行数据库字段映射 对Map类型会将value转换为string.请确保map类型中只包含基本数据类型 where\r\n条件写法 id = ?\r\n\r\n#### func (*Sql) UpdateFields\r\n\r\n```go\r\nfunc (this *Sql) UpdateFields(table string, v interface{}, fields []string, whereFmt string, whereValue ...interface{}) *ClientExecResult\r\n```\r\nmap类型无必要使用该方法 部分字段更新\r\n该接口的意义是struct类型为完整的数据库字段映射.但某些时候我们仅仅需要更新部分字段.此时,如果使用完整映射的进行更新操作 则更容易误覆盖.\r\n因此提供了这个接口进行部分字段更新. fields 就是需要更新的数据库字段名称 v,whereFmt,WhereValue 等值意义不变\r\n\r\n\r\n#### type Transaction\r\n\r\n```go\r\ntype Transaction struct {\r\n\tSql\r\n}\r\n```\r\n\r\n事务客户端\r\n\r\n#### func (*Transaction) Commit\r\n\r\n```go\r\nfunc (this *Transaction) Commit() error\r\n```\r\n提交事务\r\n\r\n#### func (*Transaction) Exec\r\n\r\n```go\r\nfunc (this *Transaction) Exec(sqlFmt string, sqlValue ...interface{}) *ClientExecResult\r\n```\r\nUPDATE `Table` SET `field_1` = Value Where id = 1 UPDATE SET `field_1` = ? WHERE\r\nid = ? ,Value,1 支持完整的SQL语句与?占位符.对于?占位符的使用请参考官方文档 ?占位符是字符串安全的,请尽量使用?占位符\r\n\r\n#### func (*Transaction) Query\r\n\r\n```go\r\nfunc (this *Transaction) Query(sqlFmt string, sqlValue ...interface{}) *ClientQueryResult\r\n```\r\nSELECT * FROM Table WHERE id = 1 SELECT * FROM Table WHERE id = ?\r\n支持完整的SQL语句与?占位符.对于?占位符的使用请参考官方文档 ?占位符是字符串安全的,请尽量使用?占位符\r\n\r\n#### func (*Transaction) Roolback\r\n\r\n```go\r\nfunc (this *Transaction) Roolback() error\r\n```\r\n回滚事务\r\n\r\n#### type UnmarshalBinary\r\n\r\n```go\r\ntype UnmarshalBinary interface {\r\n\tUnmarshalDB(data []byte) error\r\n}\r\n```\r\n\r\n#### type MarshalBinary\r\n\r\n```go\r\ntype MarshalBinary interface {\r\n\tMarshalDB() ([]byte, error)\r\n}\r\n```\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}