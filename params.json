{
  "name": "Litedb",
  "tagline": "A lite mysql operator lib for golang",
  "body": "# litedb\r\n--\r\n    import \"github.com/weixinhost/litedb\"\r\n\r\n### Intro\r\n\r\n    LiteDB 的核心设计目标是提供一个轻量级的SQL封装.\r\n    LiteDB 不会对设计范式与Mysql本身做更多的侵入\r\n    LiteDB 提供基本的SQL CURD封装\r\n    LiteDB 不提供任何形式的SQLBuilder\r\n    LiteDB 使用 `database/sql` 和 mysql驱动\r\n\r\n### Init\r\n\r\n```go\r\n    host        := \"127.0.0.1\"\r\n    port        := 3306\r\n    user        := \"root\"\r\n    password    := \"root\"\r\n    database    := \"database_name\"\r\n\r\n   client := litedb.NewTcpClient(host,port,user,password,database)\r\n\r\n\r\n```\r\n\r\n### Configure\r\n\r\n请参考[https://github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)\r\n\r\n```go\r\n\r\n    client.Config.Set(\"timeout\",\"5\")\r\n    client.Config.Set(\"charset\",\"utf8\")\r\n\r\n```\r\n\r\n### Query\r\n\r\n```go\r\n\r\nfullSql := \"SELECT * FROM `my_table` LIMIT 10\"\r\n\r\n ret := client.Query(fullSql)\r\n\r\n sql := \"SELECT * FROM `my_table` where id = ?\"\r\n\r\n ret := client.Query(sql,1)\r\n\r\n\r\n if err.Err != nil {\r\n    //errro\r\n\r\n }else{\r\n\r\n      maps,err := ret.ToMap()   //存储到一个[]map[string]string对象中\r\n      first,err := ret.FirstToMap() //将首行存储到一个map[string]string对象中\r\n\r\n      type Temp struct {\r\n\r\n        Id      int `db:\"id\"`\r\n        Name    string `db:\"name\"`\r\n\r\n      }\r\n\r\n     var listData []Temp\r\n\r\n     err := ret.ToStruct(&listData)             //将全部结果存储到结构体中,使用db:\"mysql_field_name\"的形式进行数据库字段映射\r\n\r\n     var data Temp\r\n\r\n     err := ret.FirstToStruct(&data)            //将首行存储到一个结构体中\r\n\r\n }\r\n\r\n```\r\n\r\n### Insert\r\n\r\n```go\r\n\r\ntype Temp struct {\r\n\r\n        Id      int `db:\"id\"`\r\n        Name    string `db:\"name\"`\r\n\r\n   }\r\n\r\n   newData := &Temp{\r\n     Name : \"my name\"\r\n   }\r\n\r\n\r\n    ret := client.Insert(\"table\",newData)\r\n\r\n    if ret.Err != nil {\r\n\r\n    }\r\n\r\n```\r\n\r\n\r\n### Update\r\n\r\n```go\r\ntype Temp struct {\r\n\r\n        Id      int `db:\"id\"`\r\n        Name    string `db:\"name\"`\r\n\r\n   }\r\n\r\n   newData := &Temp{\r\n     Name : \"my new name\"\r\n   }\r\n\r\n    ret := client.Update(\"table\",newData,\"id=?\",1)\r\n\r\n    if ret.Err != nil {\r\n\r\n    }\r\n\r\n\r\n```\r\n\r\n\r\n### Delete\r\n\r\n```go\r\n\r\n    ret := client.Delete(\"table\",\"id=?\",1)\r\n\r\n    if ret.Err != nil {\r\n\r\n    }\r\n\r\n\r\n```\r\n\r\n\r\n----\r\n\r\n# litedb\r\n--\r\n    import \"github.com/weixinhost/litedb\"\r\n\r\n\r\n## Usage\r\n\r\n#### func  ListStructToMap\r\n\r\n```go\r\nfunc ListStructToMap(vs interface{}) ([]map[string]string, error)\r\n```\r\n\r\n#### func  StructToMap\r\n\r\n```go\r\nfunc StructToMap(structV interface{}) (map[string]string, error)\r\n```\r\n\r\n#### func  ToInt64\r\n\r\n```go\r\nfunc ToInt64(value interface{}) (d int64)\r\n```\r\nToInt64 interface to int64\r\n\r\n#### func  ToStr\r\n\r\n```go\r\nfunc ToStr(value interface{}, args ...int) (s string)\r\n```\r\nToStr interface to string\r\n\r\n#### type Client\r\n\r\n```go\r\ntype Client struct {\r\n\tSql\r\n\tHost     string\r\n\tPort     uint32\r\n\tUser     string\r\n\tPassword string\r\n\tDatabase string\r\n\tProtocol string\r\n\tConfig   *ClientDNSConfigure\r\n}\r\n```\r\n\r\n客户端\r\n\r\n#### func  NewClient\r\n\r\n```go\r\nfunc NewClient(protocol string, host string, port uint32, user string, password string, database string) *Client\r\n```\r\n初始化数据库 此时并未打开连接池 只有在真实需要与数据库交互的时候才会进行连接.\r\n\r\n#### func  NewTcpClient\r\n\r\n```go\r\nfunc NewTcpClient(host string, port uint32, user string, password string, database string) *Client\r\n```\r\n初始化一个TCP客户端\r\n\r\n#### func (*Client) Begin\r\n\r\n```go\r\nfunc (this *Client) Begin() (*Transaction, error)\r\n```\r\n开启事务\r\n\r\n#### func (*Client) Close\r\n\r\n```go\r\nfunc (this *Client) Close() error\r\n```\r\n关闭数据库\r\n\r\n#### func (*Client) Ping\r\n\r\n```go\r\nfunc (this *Client) Ping() error\r\n```\r\nping\r\n\r\n#### type ClientDNSConfigure\r\n\r\n```go\r\ntype ClientDNSConfigure struct {\r\n}\r\n```\r\n\r\n客户端DNS配置\r\n\r\n#### func  NewClientDnsConfigure\r\n\r\n```go\r\nfunc NewClientDnsConfigure() *ClientDNSConfigure\r\n```\r\n\r\n#### func (*ClientDNSConfigure) Parse\r\n\r\n```go\r\nfunc (this *ClientDNSConfigure) Parse() string\r\n```\r\n将起解析DNS格式的字符串\r\n\r\n#### func (*ClientDNSConfigure) Remove\r\n\r\n```go\r\nfunc (this *ClientDNSConfigure) Remove(k string) bool\r\n```\r\n移除设置 Remove(\"timeout\")\r\n\r\n#### func (*ClientDNSConfigure) Set\r\n\r\n```go\r\nfunc (this *ClientDNSConfigure) Set(k, v string) bool\r\n```\r\n设置一个客户端DNS设置. Set(\"timeout\",\"5\") 详细信息请参考golang mysql DNS语法\r\n\r\n#### type ClientExecResult\r\n\r\n```go\r\ntype ClientExecResult struct {\r\n\tResult sql.Result\r\n\tErr    error //db error\r\n\tWarn   error // db warning\r\n}\r\n```\r\n\r\nClient.Exec 的结果\r\n\r\n#### type ClientQueryResult\r\n\r\n```go\r\ntype ClientQueryResult struct {\r\n\tRows *sql.Rows\r\n\tErr  error // db error\r\n\tWarn error // db warning\r\n}\r\n```\r\n\r\nClient.Query 的结果\r\n\r\n#### func (*ClientQueryResult) FirstToMap\r\n\r\n```go\r\nfunc (this *ClientQueryResult) FirstToMap() (map[string]string, error)\r\n```\r\n将Rows中的首行解析成一个map[string]string\r\n\r\n#### func (*ClientQueryResult) FirstToStruct\r\n\r\n```go\r\nfunc (this *ClientQueryResult) FirstToStruct(v interface{}) error\r\n```\r\n将首行解析成一个Struct ,需要传递一个 struct的指针. struct 定义中使用标签 tag 来进行数据库字段映射,比如 struct {\r\n\r\n    \t Id int `db:\"id\"`\r\n      Name string `db:\"name\"`\r\n\r\n}\r\n\r\n#### func (*ClientQueryResult) ToMap\r\n\r\n```go\r\nfunc (this *ClientQueryResult) ToMap() ([]map[string]string, error)\r\n```\r\nToMap 将结果集转换为Map类型. 这个操作不进行任何类型转换. 因为这里的类型转换需要一次SQL去反射字段类型. 更多的时候会得不偿失.\r\n\r\n#### func (*ClientQueryResult) ToStruct\r\n\r\n```go\r\nfunc (this *ClientQueryResult) ToStruct(containers interface{}) error\r\n```\r\n将结果集转换成一个struct 数组 var containers []Person\r\n\r\nToStruct(&containers) 对于struct类型,支持以下字段类型: int8\r\n\r\nint16\r\n\r\nint32\r\n\r\nint64\r\n\r\nint\r\n\r\nuint8\r\n\r\nuint16\r\n\r\nuint32\r\n\r\nuint64\r\n\r\nuint\r\n\r\nfloat32\r\n\r\nfloat64\r\n\r\nstring\r\n\r\n[]byte\r\n\r\n#### type MarshalBinary\r\n\r\n```go\r\ntype MarshalBinary interface {\r\n\tMarshalDB() ([]byte, error)\r\n}\r\n```\r\n\r\n支持struct中的字段拥有更复杂的类型. 需要实现该接口才能正确的打包成string插入数据库中\r\n\r\n#### type Sql\r\n\r\n```go\r\ntype Sql struct {\r\n\tExec  func(sqlFmt string, sqlValue ...interface{}) *ClientExecResult\r\n\tQuery func(sqlFmt string, sqlValue ...interface{}) *ClientQueryResult\r\n}\r\n```\r\n\r\nSql操作集\r\n\r\n#### func (*Sql) BatchInsert\r\n\r\n```go\r\nfunc (this *Sql) BatchInsert(table string, vs interface{}) *ClientExecResult\r\n```\r\n批量插入 SQL语句为: REPLACE INTO `%s` (field,field) VALUES (?,?),(?,?) 我们为什么使用REPLACE\r\nINTO 来支持批量插入. 使用Insert Into 的问题是全部待插入的数据行是事务一致的.因此,对于一次插入中,只要有行已经存在,则全部插入失败.\r\n\r\n#### func (*Sql) Delete\r\n\r\n```go\r\nfunc (this *Sql) Delete(table string, whereFmt string, whereValue ...interface{}) *ClientExecResult\r\n```\r\n根据Where条件删除数据\r\n\r\n#### func (*Sql) Insert\r\n\r\n```go\r\nfunc (this *Sql) Insert(table string, v interface{}) *ClientExecResult\r\n```\r\n对Struct类型的支持,使用 db tag 进行数据库字段映射 对Map类型会将value转换为string.请确保map类型中只包含基本数据类型\r\n\r\n#### func (*Sql) InsertOrUpdate\r\n\r\n```go\r\nfunc (this *Sql) InsertOrUpdate(table string, v interface{}) *ClientExecResult\r\n```\r\n插入或更新行(当主键已存在的时候) SQL语句为: INSERT INTO .... ON DUPLICATE KEY UPDATE .... 全部字段更新\r\n\r\n#### func (*Sql) InsertOrUpdateFields\r\n\r\n```go\r\nfunc (this *Sql) InsertOrUpdateFields(table string, v interface{}, updateFields ...string) *ClientExecResult\r\n```\r\nmap类型无必要使用该方法 插入或更新行(当主键已存在的时候) SQL语句为: INSERT INTO .... ON DUPLICATE KEY UPDATE\r\n.... 可以指定更新字段\r\n\r\n#### func (*Sql) Update\r\n\r\n```go\r\nfunc (this *Sql) Update(table string, v interface{}, whereFmt string, whereValue ...interface{}) *ClientExecResult\r\n```\r\n对Struct类型的支持,使用 db tag 进行数据库字段映射 对Map类型会将value转换为string.请确保map类型中只包含基本数据类型 where\r\n条件写法 id = ?\r\n\r\n#### func (*Sql) UpdateFields\r\n\r\n```go\r\nfunc (this *Sql) UpdateFields(table string, v interface{}, fields []string, whereFmt string, whereValue ...interface{}) *ClientExecResult\r\n```\r\nmap类型无必要使用该方法 部分字段更新\r\n该接口的意义是struct类型为完整的数据库字段映射.但某些时候我们仅仅需要更新部分字段.此时,如果使用完整映射的进行更新操作 则更容易误覆盖.\r\n因此提供了这个接口进行部分字段更新. fields 就是需要更新的数据库字段名称 v,whereFmt,WhereValue 等值意义不变\r\n\r\n#### type StrTo\r\n\r\n```go\r\ntype StrTo string\r\n```\r\n\r\nStrTo is the target string\r\n\r\n#### func (StrTo) Bool\r\n\r\n```go\r\nfunc (f StrTo) Bool() (bool, error)\r\n```\r\nBool string to bool\r\n\r\n#### func (*StrTo) Clear\r\n\r\n```go\r\nfunc (f *StrTo) Clear()\r\n```\r\nClear string\r\n\r\n#### func (StrTo) Exist\r\n\r\n```go\r\nfunc (f StrTo) Exist() bool\r\n```\r\nExist check string exist\r\n\r\n#### func (StrTo) Float32\r\n\r\n```go\r\nfunc (f StrTo) Float32() (float32, error)\r\n```\r\nFloat32 string to float32\r\n\r\n#### func (StrTo) Float64\r\n\r\n```go\r\nfunc (f StrTo) Float64() (float64, error)\r\n```\r\nFloat64 string to float64\r\n\r\n#### func (StrTo) Int\r\n\r\n```go\r\nfunc (f StrTo) Int() (int, error)\r\n```\r\nInt string to int\r\n\r\n#### func (StrTo) Int16\r\n\r\n```go\r\nfunc (f StrTo) Int16() (int16, error)\r\n```\r\nInt16 string to int16\r\n\r\n#### func (StrTo) Int32\r\n\r\n```go\r\nfunc (f StrTo) Int32() (int32, error)\r\n```\r\nInt32 string to int32\r\n\r\n#### func (StrTo) Int64\r\n\r\n```go\r\nfunc (f StrTo) Int64() (int64, error)\r\n```\r\nInt64 string to int64\r\n\r\n#### func (StrTo) Int8\r\n\r\n```go\r\nfunc (f StrTo) Int8() (int8, error)\r\n```\r\nInt8 string to int8\r\n\r\n#### func (*StrTo) Set\r\n\r\n```go\r\nfunc (f *StrTo) Set(v string)\r\n```\r\nSet string\r\n\r\n#### func (StrTo) String\r\n\r\n```go\r\nfunc (f StrTo) String() string\r\n```\r\nString string to string\r\n\r\n#### func (StrTo) Uint\r\n\r\n```go\r\nfunc (f StrTo) Uint() (uint, error)\r\n```\r\nUint string to uint\r\n\r\n#### func (StrTo) Uint16\r\n\r\n```go\r\nfunc (f StrTo) Uint16() (uint16, error)\r\n```\r\nUint16 string to uint16\r\n\r\n#### func (StrTo) Uint32\r\n\r\n```go\r\nfunc (f StrTo) Uint32() (uint32, error)\r\n```\r\nUint32 string to uint31\r\n\r\n#### func (StrTo) Uint64\r\n\r\n```go\r\nfunc (f StrTo) Uint64() (uint64, error)\r\n```\r\nUint64 string to uint64\r\n\r\n#### func (StrTo) Uint8\r\n\r\n```go\r\nfunc (f StrTo) Uint8() (uint8, error)\r\n```\r\nUint8 string to uint8\r\n\r\n#### type Transaction\r\n\r\n```go\r\ntype Transaction struct {\r\n\tSql\r\n}\r\n```\r\n\r\n事务客户端\r\n\r\n#### func (*Transaction) Commit\r\n\r\n```go\r\nfunc (this *Transaction) Commit() error\r\n```\r\n提交事务\r\n\r\n#### func (*Transaction) Roolback\r\n\r\n```go\r\nfunc (this *Transaction) Roolback() error\r\n```\r\n回滚事务\r\n\r\n#### type UnmarshalBinary\r\n\r\n```go\r\ntype UnmarshalBinary interface {\r\n\tUnmarshalDB(data []byte) error\r\n}\r\n```\r\n\r\n对 MarshalBinary 的反向操作\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}